
(defun is-op (str)
    (cond
        ((string= str "+") "OP_PLUS")
        ((string= str "-") "OP_MINUS")
        ((string= str "*") "OP_MULT")
        ((string= str "/") "OP_DIV")
        ((string= str "(") "OP_OP")
        ((string= str ")") "OP_CP")
        ((string= str "\"") "OP_OC")
        ((string= str ",") "OP_COMMA")
        ((string= str "**") "OP_DBMULT")
        (T NIL)
    )
)

(defun is-keyword (str)
    (setf s (string-downcase str))
    (cond
        ((string= s "and") "KW_AND")
        ((string= s "or") "KW_OR")
        ((string= s "not") "KW_NOT")
        ((string= s "equal") "KW_EQUAL")
        ((string= s "less") "KW_LESS")
        ((string= s "nil") "KW_NIL")
        ((string= s "list") "KW_LIST")
        ((string= s "append") "KW_APPEND")
        ((string= s "concat") "KW_CONCAT")
        ((string= s "set") "KW_SET")
        ((string= s "deffun") "KW_DEFFUN")
        ((string= s "for") "KW_FOR")
        ((string= s "if") "KW_IF")
        ((string= s "exit") "KW_EXIT")
        ((string= s "load") "KW_LOAD")
        ((string= s "disp") "KW_DISP")
        ((string= s "true") "KW_TRUE")
        ((string= s "false") "KW_FALSE")
        (T NIL)
    )
)


(defun is-identifier (str)
    (if (is-letter(char str 0))
        (loop for i across str do (when (not (is-alnum i)) (return-from is-identifier)))
        (return-from is-identifier)) "IDENTIFIER")

(defun is-value (str)

    (loop for i across str do (when (not (is-digit i)) (return-from is-value))) "VALUE")

(defun is-digit (chr)
	(and (char>= chr #\0) (char<= chr #\9)))

(defun is-letter (chr)
	(or (and (char>= chr #\A) (char<= chr #\Z)) (and (char>= chr #\a) (char<= chr #\z))))

(defun is-white (str)
    (setf c (char str 0))
    (or (char= c #\SPACE) (char= c #\RETURN)
        (char= c #\NEWLINE) (char= c #\TAB)
    )
)
(defun is-alnum (chr)
	(or (and (string>= chr "0") (string<= chr "9")) (and (string>= chr "A") (string<= chr "Z")) (and (string>= chr "a") (string<= chr "z")))
)

(defun split-strings (str delims)
  (labels ((delim-p (c)
             (position c delims))
           (tokens (stri test)
             (when (> (length stri) 0)
               (let ((p (position-if test stri)))
                 (if p
                     (if (= p 0)
                         (cons (subseq stri 0 (1+ p))
                               (tokens (subseq stri (1+ p) nil) test))
                         (cons (subseq stri 0 p)
                               (tokens (subseq stri p nil) test)))
                     (cons stri nil))))))
    (tokens str #'delim-p)))

(defun string-to-list (line)
    (defparameter list (split-strings line '(#\, #\" #\  #\) #\( )) )
    (return-from string-to-list list)
)
;;(defun gppinterpreter ()
;;    (loop for line = (read-line) while (not (string= line "")) do (interpreter line)))

(defun interpreter (line)
    (defparameter str-line (string-to-list line))
    (defvar str-line-ignored nil)
    (defparameter token-list (lexer str-line str-line-ignored))
    
    (return-from interpreter token-list)
)
(defun lexer(str-line line-list)
    (setq lexer-list (list 1))
    (loop
        (setq str (car str-line))
        (if(equal str NIL) (return (cons (reverse line-list) (cdr (reverse lexer-list)))))
        (cond
                ((is-keyword str)
                    (push (is-keyword str) lexer-list)
                )
                ((is-value str)
                    (push "VALUE" lexer-list)
                )
                ((is-op str)
                    (push (is-op str) lexer-list)
                )
                ((is-white str)
                ;;ignored 
                )
                ((is-identifier str)
                    (push "IDENTIFIER" lexer-list)
                )
        )
        (if (not (is-white str)) (push str line-list) )
        (setq str-line (cdr str-line)))
)

